---
title: "Congressional Committee Data Wrangling"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r}
# Load libraries here
library(readr)
library(here)
library(dplyr)
library(tidyverse)
library(stringr)
library(statnet)
```


## Loading the data

```{r}
library(readr)
committee_membership_current <- read_csv(here("Congressional Committee Shiny/committee-membership-current.csv"))
View(committee_membership_current)

committees_current <- read_csv(here("Congressional Committee Shiny/committees-current.csv"))
View(committees_current)
```

## Make the column with the key in committees_current
- Otherwise I will not be able to link the names of the committees

```{r}
committees_current2 <- committees_current %>%
  mutate(key = paste(thomas_id, sub_thomas_id, sep = "")) %>%
  mutate(key = str_replace_all(key, 
                               "NA",
                               ""))
```

## Join the dataframes together by the key! :) Hasn't proved super useful?

```{r}
committees_current2 <- committees_current2 %>%
  select(name, sub_name, key, type) %>%
  rename(com_name = name)

committees <- left_join(committee_membership_current, committees_current2, by = c("thomas_id" = "key"))
```


## Set up the "edge list" (cheating a lil bit, as it is two mode and thus must have two distinct columns, but it works!)

```{r}
congressperson <- committees %>%
  distinct(name) %>%
  rename(label = name)

committee_names <- committees %>%
  distinct(thomas_id) %>%
  rowid_to_column("id")

committee_nodes <- committees %>%
  select(name, thomas_id) %>%
  arrange(name)

nodes <- left_join(committee_nodes, committee_names, by = "thomas_id") %>%
  select(-thomas_id) %>%
  rename(committee = id)

#names(nodes) <- NULL
#nodes
```
## Get affiliation data for gender

```{r}
# Need to grab gender :(

one16 <- read_csv("116_cong.csv")
one16 <- one16 %>%
  rename(name = officialFullName)

congressperson_affiliation <- congressperson %>%
  rowid_to_column("id")
  
congressperson_gender <- left_join(congressperson_affiliation, one16, by = c("label" = "name"))

gender <- read_csv("gender.csv")

gender <- gender %>%
  mutate(gender = case_when(gender == 'M' ~ 0,
                            gender == 'F' ~ 1))

congressperson_affiliation <- inner_join(congressperson_affiliation, gender, by = "id")

gender_color <- gender %>%
  mutate(gender = case_when(gender == 0 ~ "blue",
                            gender == 1 ~ "pink"))

congressperson_affiliation <- inner_join(congressperson_affiliation, gender, by = "id")

congressperson_affiliation <- congressperson_affiliation %>%
  select(-label.x, - label.y, -label)
```
## Doing some thinking... where do I put this data? Load the committees csv + gender csv and copy + paste this code?

```{r}
# Join from committees: party, rank, chamber (saved as "type" in committees_current), leadership (title)

# Will not be making a color vector for this one, as we will FILTER the dataset to only include what the user inputs using this dataframe :)
committees_chamber <- committees %>%
  drop_na(type) %>%
  distinct(name, .keep_all = TRUE) %>%
  full_join(congressperson1, by = c("name" = "label")) %>%
  select(type, id)

congressperson_affiliation <- inner_join(congressperson_affiliation, committees_chamber, by = "id")

# Side note: majority is Republican
committees_party <- committees %>%
  full_join(congressperson1, by = c("name" = "label")) %>%
  distinct(id, .keep_all = TRUE) %>%
  select(id, party) %>%
  mutate(party = case_when(party == "majority" ~ 0,
                           party == "minority" ~ 1))

congressperson_affiliation <- inner_join(congressperson_affiliation, committees_party, by = "id")

committees_party_colors <- committees_party %>%
  mutate(party = case_when(party == 0 ~ "red",
                           party == 1 ~ "blue"))

congressperson_affiliation <- inner_join(congressperson_affiliation, committees_party_colors, by = "id")

committees_leadership <- committees %>%
  full_join(congressperson1, by = c("name" = "label")) %>%
  distinct(id, .keep_all = TRUE) %>%
  select(name, id, title) %>%
  mutate(title = case_when(title %in% c("Chair", "Ranking Member") ~ 1,
                           is.na(title) == TRUE ~ 0))

congressperson_affiliation <- inner_join(congressperson_affiliation, committees_leadership, by = "id")

committees_leadership_colors <- committees_leadership %>%
  mutate(title = case_when(title == 1 ~ "purple",
                           title == 0 ~ "gray"))

congressperson_affiliation <- inner_join(congressperson_affiliation, committees_leadership_colors, by = "id")

congressperson_affiliation <- congressperson_affiliation %>%
  select(-name.y) %>%
  rename(party_bin = party.x,
         party_color = party.y,
         title_bin = title.x,
         title_color = title.y,
         gender_bin = gender.x,
         gender_color = gender.y,
         name = name.x)

# ROBIN USE THIS CODE TO CONVERT THE ROW IN THE DATAFRAME TO A VECTOR TO USE IN THE GRAPHY GRAPH
leadership_colors <- congressperson_affiliation[['title_color']]
```


## Write to a csv
```{r, eval = FALSE}
write_csv(nodes, file = "committee_edge_list.csv")
write_csv(congressperson_affiliation, file = "congressperson_affiliation.csv")
```


## Turn it into a two mode network! (using `statnet`)

```{r}
com <- read.csv("committee_edge_list.csv", 
                #directed = FALSE,
                skip = 1,
                header = FALSE)

head(com)

# With the four line script, below, we are saving all the unique names from the first column (first mode) into an object called “mode1”, and all the unique names from the second column (second mode) into an object called “mode2”
mode1 <- unique(com[,1])
mode2 <- unique(com[,2])
length(mode1)
## 479
length(mode2)
## 215

net <- as.network(com, 
                  bipartite=215,   # Number of nodes in the second mode (events)
                  directed=FALSE)

gplot(net, usearrows = FALSE)
```


## Split it into one-mode networks for the purpose of graphing + finding centrality measures (who holds power more significantly + why???). Can I graph the thing below?? hm

```{r}
bipartite_matrix <- as.matrix(net)

#t(bipartite_matrix)

event_matrix_prod <- bipartite_matrix %*% t(bipartite_matrix)

diag(event_matrix_prod) <- 0

event_matrix_prod

# Will have to experiment with vertex.col to get this hecking thing to graph colors by my affiliation data

# edge.lwd changes the thickness of the edges by the number of them
gplot(event_matrix_prod, vertex.col = leadership_colors, thresh = 1, jitter = TRUE, usearrows = FALSE, vertex.cex = 2)

?gplot
```

## Further options: use one of the methods detailed at the bottom of the instructions (Yule's Q, Pearson Correlation, **Jaccard Similarity**), then use tnet or statnet to calculate the measures. I have, however, hit a wall for the night and will finish this part up tomorrow :)
- This can be done for my measures, and I can join the affiliation data to do the statistical calculations


```{r}

```


## Centrality measures in `statnet`

```{r}
# First we need to binarize the network

library(ade4) # If you have not already done so

# I have a bipartite_matrix and net!
bipartite_matrix <- as.matrix(net)  # Extract the matrix

congressperson_jaccard <- dist.binary(t(bipartite_matrix), 
                                      method=1, upper=TRUE, 
                                      diag = FALSE) # Method #1 is "Jaccard Index"
#event_jaccard <- dist.binary(bipartite_matrix, 
 #                            method=1, upper=TRUE, 
  #                           diag = FALSE) 

congressperson_jaccard <- as.matrix(congressperson_jaccard)   
diag(congressperson_jaccard) <- 0

# women_jaccard          # Look at the matrix before you binarize
congressperson_jaccard <- ifelse(congressperson_jaccard>0.95, 1, 0)     # Binarize

# jaccard_women      # Take a look at the matrix if you like.

jacc_congressperson <- as.network(congressperson_jaccard,    # Create a statnet network
                                  directed=FALSE)
gplot(jacc_congressperson,
      usearrows = FALSE, 
      jitter = TRUE,
      vertex.cex = 2)
```

```{r}
# Unsure why, but betweenness() and closeness() take a VERY long time to run/don't run.
IDs <- jacc_congressperson%v%"vertex.names"
congress_deg  <- degree(jacc_congressperson)
#congress_bet  <- betweenness(jacc_congressperson)
#congress_clos <- closeness(jacc_congressperson,
           #             cmode="suminvdir")
congress_eig  <- evcent(jacc_congressperson)

congress_cent_df <- data.frame(IDs, 
                            congress_deg, 
                            #congress_bet, 
                            #congress_clos, 
                            congress_eig)

congress_cent_df

congressperson_affiliation2 <- inner_join(congressperson_affiliation, congress_cent_df, by = c("name" = "IDs"))

```
```{r}
# Hypothesis test:
t.test(congress_deg ~ party_bin, data = congressperson_affiliation2)
t.test(congress_eig ~ party_bin, data = congressperson_affiliation2)

# Save into dataframe
library(broom)
gender_deg <- tidy(t.test(congress_deg ~ gender_bin, data = congressperson_affiliation2))

# Definitely will also have to graph the results (boxplot of the centralization measures) so we know which one is higher :)
```




